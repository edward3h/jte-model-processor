package org.ethelred.jte.processor;

import com.sun.source.util.Trees;
import gg.jte.runtime.Constants;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.ProcessingEnvironment;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedOptions;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.PackageElement;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.VariableElement;
import javax.lang.model.type.TypeKind;
import javax.lang.model.util.ElementScanner14;
import javax.lang.model.util.Elements;
import javax.lang.model.util.Types;
import java.io.IOException;
import java.util.HashSet;
import java.util.Set;
import java.util.regex.Pattern;

@SupportedSourceVersion(SourceVersion.RELEASE_20)
@SupportedAnnotationTypes("*") // JTE classes are not currently annotated, so we need to match all
@SupportedOptions({JteModelProcessor.PACKAGE_OPTION})
public class JteModelProcessor extends AbstractProcessor {
    public static final String PACKAGE_OPTION = "org.ethelred.jte.generator.package";
    private static final Pattern NAME_PATTERN = Pattern.compile("(\\w+)\\.jte$");

    private String packageName = Constants.PACKAGE_NAME_PRECOMPILED;
    private boolean done = false;

    @Override
    public synchronized void init(ProcessingEnvironment processingEnv) {
        super.init(processingEnv);
        processingEnv.getMessager().printNote("JteModelProcessor init");
        var packageFromOptions = processingEnv.getOptions().get(PACKAGE_OPTION);
        if (packageFromOptions != null && !packageFromOptions.isBlank()) {
            packageName = packageFromOptions;
        }
    }

    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        if (done) {
            // JTE classes are not generated by annotation processing, hence we expect them all to be processed in the first round
            return false;
        }
        done = true;
        processingEnv.getMessager().printNote("JteModelProcessor process " + roundEnv.getRootElements());

        var discovery = new DiscoveryVisitor(packageName);
        var jteGenerated = new HashSet<TypeElement>();
        discovery.scan(roundEnv.getRootElements(), jteGenerated);

        var renderers = jteGenerated.stream()
                .map(e -> e.accept(new RendererVisitor(processingEnv.getElementUtils()), null))
                .map(RendererBuilder::build)
                .toList();

        if (!renderers.isEmpty()) {
            var filer = processingEnv.getFiler();
            try {
                var fg = new FacadeGenerator(packageName, renderers);
                var fileOutput = filer.createSourceFile(packageName + "." + fg.interfaceName());
                try (var w = fileOutput.openWriter()) {
                    w.write(fg.generateInterface());
                }
                fileOutput = filer.createSourceFile(packageName + "." + fg.staticClassname());
                try (var w = fileOutput.openWriter()) {
                    w.write(fg.generateStatic());
                }
                fileOutput = filer.createSourceFile(packageName + "." + fg.dynamicClassname());
                try (var w = fileOutput.openWriter()) {
                    w.write(fg.generateDynamic());
                }
            } catch (IOException e) {
                processingEnv.getMessager().printError("Error generating facade " + e.getMessage());
            }
        } else {
            processingEnv.getMessager().printWarning("JteModelProcessor no renderers found");
        }


        return false; // must always return false, since we process every element
    }

    private static class DiscoveryVisitor extends ElementScanner14<Void, Set<TypeElement>> {
        private final String packageName;

        public DiscoveryVisitor(String packageName) {
            this.packageName = packageName;
        }

        @Override
        public Void visitPackage(PackageElement e, Set<TypeElement> discoveredRenderClesses) {
            if (packageMatches(e)) {
                return super.visitPackage(e, discoveredRenderClesses);
            }
            return null;
        }

        @Override
        public Void visitType(TypeElement e, Set<TypeElement> discoveredRenderClesses) {
            if (isClass(e) && packageMatches(e.getEnclosingElement()) && nameMatches(e)) {
                discoveredRenderClesses.add(e);
            }
            return null;
        }

        private boolean nameMatches(TypeElement e) {
            var name = e.getSimpleName().toString();
            return name.startsWith(Constants.CLASS_PREFIX) && name.endsWith(Constants.CLASS_SUFFIX);
        }

        private boolean packageMatches(Element e) {
            if (e.getKind().equals(ElementKind.PACKAGE)) {
                var name = e.asType().toString();
                return name.equals(packageName) || name.startsWith(packageName + "."); // match sub-packages, although they do not normally represent containment
            }
            return false;
        }

        private boolean isClass(TypeElement e) {
            return e.getKind().isClass();
        }
    }

    private static class RendererVisitor extends ElementScanner14<RendererBuilder, Void> {
        private final Elements elements;

        private RendererVisitor(Elements elements) {
            super(RendererBuilder.builder());
            this.elements = elements;
        }

        @Override
        public RendererBuilder visitType(TypeElement e, Void unused) {
            DEFAULT_VALUE.originator(e);
            DEFAULT_VALUE.className(e.getSimpleName().toString());
            DEFAULT_VALUE.packageName(elements.getPackageOf(e).asType().toString());
            return super.visitType(e, unused);
        }

        @Override
        public RendererBuilder visitExecutable(ExecutableElement e, Void unused) {
            if (e.getKind().equals(ElementKind.METHOD) && e.getSimpleName().contentEquals("render") && e.getReturnType().getKind().equals(TypeKind.VOID)) {
                var parameters = e.getParameters();
                // expect TemplateOutput, then HtmlInterceptor, then properties
                if (parameters.size() >= 3) {
                    var output = parameters.get(0);
                    var interceptor = parameters.get(1);
                    if (output.asType().toString().endsWith("TemplateOutput") && interceptor.asType().toString().endsWith("Interceptor")) {
                        for (var i = 2; i < parameters.size(); i++) {
                            var parameter = parameters.get(i);
                            DEFAULT_VALUE.addParams(
                              RendererParamBuilder.builder()
                                      .name(parameter.getSimpleName().toString())
                                      .type(parameter.asType().toString())
                                      .varargs(e.isVarArgs() && i == parameters.size() - 1)
                                      .build()
                            );
                        }
                    }
                }
            }
            return super.visitExecutable(e, unused);
        }

        @Override
        public RendererBuilder visitVariable(VariableElement e, Void unused) {
            if (e.getSimpleName().contentEquals(Constants.NAME_FIELD) && e.getConstantValue() instanceof String value) {
                var matcher = NAME_PATTERN.matcher(value);
                if (matcher.find()) {
                    DEFAULT_VALUE.templateFile(value);
                    DEFAULT_VALUE.templateName(matcher.group(1));
                }
            }
            return super.visitVariable(e, unused);
        }
    }
}
